const fs = require('fs');
const path = require('path');
const { z } = require('zod');
const url = require('url');

const API_DEFS_DIR = path.join(__dirname, '../apiDefs');
const OUTPUT_FILE = path.join(__dirname, 'kernelApiClient.js');

const GENERATED_BANNER = `// Generated by generateSingleFileClient.cjs, do not edit manually.
// Timestamp: ${new Date().toISOString()}
// Based on API definitions from: ${API_DEFS_DIR}

/**
 * @typedef {object} KernelApiClientOptions
 * @property {string} [baseUrl="http://127.0.0.1:6806"] - The base URL of the Siyuan Kernel.
 * @property {string} [apiToken=""] - The API token for authentication.
 * @property {function} [customFetch=globalThis.fetch] - A custom fetch implementation.
 */
`;

// Helper to check if an object is a Zod schema (ZodRawShape) - Provided by user
const isZodRawShape = (obj) => {
    if (typeof obj !== "object" || obj === null) return false;
    // Allow empty object {} to be handled by later logic, not strictly a "raw shape with Zod types"
    if (Object.keys(obj).length === 0 && !obj._def) return false; 
    return Object.values(obj).some(v => v?._def?.typeName);
};

// Function to get basic JSDoc type name from Zod type
function getZodPrimitiveTypeName(zodType) {
    if (!zodType || !zodType._def || !zodType._def.typeName) return 'any';
    const typeName = zodType._def.typeName;
    switch (typeName) {
        case 'ZodString': return 'string';
        case 'ZodNumber': return 'number';
        case 'ZodBoolean': return 'boolean';
        case 'ZodDate': return 'Date';
        case 'ZodNull': return 'null';
        case 'ZodVoid': return 'void';
        case 'ZodAny': return 'any';
        case 'ZodUnknown': return 'unknown';
        case 'ZodNever': return 'never';
        case 'ZodBigInt': return 'bigint';
        case 'ZodSymbol': return 'symbol';
        case 'ZodUndefined': return 'undefined';
        default: return 'any';
    }
}

/**
 * Recursively parses a Zod type and generates its JSDoc representation.
 * @param {object} zodType - The Zod type instance.
 * @param {string} linePrefix - The string prefix for each generated JSDoc line for nested properties (e.g., "  *    ").
 * @returns {{ type: string, description: string, details: string[] }}
 *  - type: The JSDoc type string (e.g., "string", "Array<object>").
 *  - description: The description of the Zod type.
 *  - details: An array of fully formatted JSDoc lines for properties of an object type.
 */
function parseZodTypeForJsDoc(zodType, linePrefix) {
    if (!zodType || !zodType._def) {
        return { type: 'any', description: '', details: [] };
    }

    const typeName = zodType._def.typeName;
    let description = zodType.description || '';
    let jsDocType = getZodPrimitiveTypeName(zodType);
    let details = [];

    switch (typeName) {
        case 'ZodObject':
            jsDocType = 'object';
            const shape = zodType._def.shape();
            const propertyLinePrefix = linePrefix + '  '; // Indent properties further
            for (const key in shape) {
                const propTypeInstance = shape[key];
                const propJsDoc = parseZodTypeForJsDoc(propTypeInstance, propertyLinePrefix);
                let propFinalDescription = propJsDoc.description || key;
                
                details.push(`${propertyLinePrefix}@property {${propJsDoc.type}} ${key} - ${propFinalDescription}`);
                if (propJsDoc.details.length > 0) {
                    details.push(...propJsDoc.details); 
                }
            }
            break;
        case 'ZodArray':
            const elementType = zodType._def.type;
            const elementJsDoc = parseZodTypeForJsDoc(elementType, linePrefix); 
            jsDocType = `Array<${elementJsDoc.type}>`;
            if (elementType._def?.typeName === 'ZodObject' && elementJsDoc.details.length > 0) {
                 // details.push(...elementJsDoc.details.map(d => `${linePrefix}(element)${d.substring(linePrefix.length)}`));
            }
            break;
        case 'ZodOptional':
        case 'ZodNullable':
            const innerTypeOptionalNullable = zodType._def.innerType;
            const innerJsDocON = parseZodTypeForJsDoc(innerTypeOptionalNullable, linePrefix);
            jsDocType = innerJsDocON.type + (typeName === 'ZodOptional' ? ' | undefined' : ' | null');
            description = description || innerJsDocON.description; 
            details = innerJsDocON.details; 
            break;
        case 'ZodUnion':
            const options = zodType._def.options;
            jsDocType = options.map(opt => parseZodTypeForJsDoc(opt, linePrefix).type).join(' | ');
            break;
        case 'ZodRecord':
            const keyType = zodType._def.keyType ? parseZodTypeForJsDoc(zodType._def.keyType, linePrefix).type : 'string';
            const valueTypeInfo = parseZodTypeForJsDoc(zodType._def.valueType, linePrefix);
            jsDocType = `Record<${keyType}, ${valueTypeInfo.type}>`;
            description = description || valueTypeInfo.description; 
            details = valueTypeInfo.details; 
            break;
        case 'ZodLiteral':
            const literalValue = zodType._def.value;
            jsDocType = typeof literalValue === 'string' ? `"${literalValue.replace(/"/g, '\\"')}"` : String(literalValue);
            break;
        case 'ZodEnum':
            jsDocType = zodType._def.values.map(v => typeof v === 'string' ? `"${v.replace(/"/g, '\\"')}"` : String(v)).join(' | ');
            break;
        case 'ZodLazy': 
            jsDocType = 'object'; 
            description = description || 'Lazily loaded type, structure defined elsewhere.';
            break;
    }
    return { type: jsDocType, description, details };
}

/**
 * Generates JSDoc lines for parameters or return types.
 * @param {function} apiDefSchemaFn - The function from apiDef (e.g., zodRequestSchema).
 * @param {object} zInstance - The Zod instance.
 * @param {string} baseJsDocLinePrefix - The prefix for each JSDoc line (e.g., "   * ").
 * @param {boolean} isReturn - True if generating for @returns, false for @param.
 * @returns {string[]} An array of JSDoc lines.
 */
function generateJsDocLinesFromSchema(apiDefSchemaFn, zInstance, baseJsDocLinePrefix, isReturn = false) {
    if (!apiDefSchemaFn) return [];

    let schemaOrShape;
    try {
        schemaOrShape = apiDefSchemaFn(zInstance);
    } catch (e) {
        return [];
    }

    const lines = [];

    if (!schemaOrShape || (typeof schemaOrShape === 'object' && !schemaOrShape._def && Object.keys(schemaOrShape).length === 0)) {
        const desc = (schemaOrShape && typeof schemaOrShape === 'object' && schemaOrShape.description) ? schemaOrShape.description : (isReturn ? 'The response from the server.' : 'Request payload');
        const type = isReturn ? 'Promise<object>' : 'object';
        const paramOrReturn = isReturn ? `@returns {${type}} ${desc}` : `@param {${type}} data - ${desc}`;
        lines.push(`${baseJsDocLinePrefix}${paramOrReturn}`);
        return lines;
    }
    
    if (isZodRawShape(schemaOrShape)) {
        const overallDescription = schemaOrShape.description || (isReturn ? 'The response from the server.' : 'Request payload');
        const baseType = 'object';
        const promiseWrappedType = isReturn ? `Promise<${baseType}>` : baseType;
        
        const mainLine = isReturn ? `@returns {${promiseWrappedType}} ${overallDescription}` : `@param {${baseType}} data - ${overallDescription}`;
        lines.push(`${baseJsDocLinePrefix}${mainLine}`);

        const propertyLinePrefix = baseJsDocLinePrefix + '  '; 
        for (const key in schemaOrShape) {
            if (key === 'description') continue; 

            const propZodType = schemaOrShape[key];
            if (propZodType && propZodType._def) { 
                const propJsDoc = parseZodTypeForJsDoc(propZodType, propertyLinePrefix); 
                let propFinalDescription = propJsDoc.description || key;

                lines.push(`${propertyLinePrefix}@property {${propJsDoc.type}} ${key} - ${propFinalDescription}`);
                if (propJsDoc.details.length > 0) {
                    lines.push(...propJsDoc.details);
                }
            } else {
                lines.push(`${propertyLinePrefix}@property {any} ${key} - ${key}`);
            }
        }
    } else if (schemaOrShape && schemaOrShape._def) { 
        const parsedResult = parseZodTypeForJsDoc(schemaOrShape, baseJsDocLinePrefix);
        let mainDescription = parsedResult.description || (isReturn ? 'The response from the server.' : 'Request payload');

        if (isReturn) {
            let returnType = parsedResult.type;
            if (returnType === 'void') { 
                returnType = 'Promise<void>';
            } else {
                returnType = `Promise<${returnType}>`;
            }
            lines.push(`${baseJsDocLinePrefix}@returns {${returnType}} ${mainDescription}`);
        } else { 
            lines.push(`${baseJsDocLinePrefix}@param {${parsedResult.type}} data - ${mainDescription}`);
        }

        if (parsedResult.details.length > 0 && parsedResult.type === 'object') {
            lines.push(...parsedResult.details);
        }
    } else {
        const desc = (typeof schemaOrShape === 'object' && schemaOrShape.description) ? schemaOrShape.description : (isReturn ? 'The response from the server.' : 'Request payload');
        const type = isReturn ? 'Promise<any>' : 'any';
        const paramOrReturn = isReturn ? `@returns {${type}} ${desc}` : `@param {${type}} data - ${desc}`;
        lines.push(`${baseJsDocLinePrefix}${paramOrReturn}`);
    }
    return lines;
}

async function getAllApiDefs() {
    const allDefs = [];
    const files = fs.readdirSync(API_DEFS_DIR);
    for (const file of files) {
        if (file.endsWith('.js')) {
            const groupName = file.replace('.js', '');
            try {
                const modulePath = path.join(API_DEFS_DIR, file);
                const defsModule = await import(url.pathToFileURL(modulePath).href);
                const apiDefsArray = defsModule[`${groupName}ApiDefs`];
                if (Array.isArray(apiDefsArray)) {
                    apiDefsArray.forEach(def => {
                        allDefs.push({ ...def, groupName });
                    });
                } else {
                    console.warn(`Skipping ${file}: expected ${groupName}ApiDefs to be an array.`);
                }
            } catch (error) {
                console.error(`Error loading API definitions from ${file}:`, error);
            }
        }
    }
    return allDefs;
}

function generateMethodJsDoc(apiDef, hasDataParam) {
    const baseIndentStr = '  '; 
    const jsDocLinePrefix = `${baseIndentStr} * `;
    
    let jsDocLines = [`${baseIndentStr}/**`];
    jsDocLines.push(`${jsDocLinePrefix}${apiDef.zh_cn || apiDef.en}`);
    if (apiDef.deprecated) {
        jsDocLines.push(`${jsDocLinePrefix}@deprecated ${typeof apiDef.deprecated === 'string' ? apiDef.deprecated : ''}`);
    }
    jsDocLines.push(`${jsDocLinePrefix}Endpoint: \`${apiDef.method} ${apiDef.endpoint}\``);
    if (apiDef.needAuth) {
        jsDocLines.push(`${jsDocLinePrefix}Requires authentication.`);
    }

    if (hasDataParam && apiDef.zodRequestSchema) {
        const requestLines = generateJsDocLinesFromSchema(apiDef.zodRequestSchema, z, jsDocLinePrefix, false);
        jsDocLines.push(...requestLines);
    } else if (hasDataParam) { 
        jsDocLines.push(`${jsDocLinePrefix}@param {object} data - Request payload`);
    }

    if (apiDef.zodResponseSchema) {
        const responseLines = generateJsDocLinesFromSchema(apiDef.zodResponseSchema, z, jsDocLinePrefix, true);
        jsDocLines.push(...responseLines);
    } else {
        jsDocLines.push(`${jsDocLinePrefix}@returns {Promise<any>} The response data from the server.`);
    }

    jsDocLines.push(`${jsDocLinePrefix}@throws {Error} If the request fails or the server returns an error.`);
    jsDocLines.push(`${baseIndentStr} */`);
    // When joining lines for the final string, use \n which is a literal newline in a template string or regular string.
    // If this string is then written to a file, \n will correctly become a newline character.
    return jsDocLines.join('\n') + '\n'; 
}

async function generateKernelApiClient() {
    const apiDefs = await getAllApiDefs();
    let classBody = '';
    let methodCount = 0; // Initialize counter

    classBody += `
class KernelApiClient {
  /**
   * Creates an instance of KernelApiClient.
   * @param {KernelApiClientOptions} [options={}]
   */
  constructor(options = {}) {
    this.baseUrl = options.baseUrl || 'http://127.0.0.1:6806';
    this.apiToken = options.apiToken || '';
    this.customFetch = options.customFetch || globalThis.fetch;

    if (!this.customFetch) {
      throw new Error('Fetch API is not available. Please provide a customFetch implementation if running in an environment without globalThis.fetch.');
    }
    if (this.baseUrl.endsWith('/')) {
        this.baseUrl = this.baseUrl.slice(0, -1);
    }
  }

  async _fetchWrapper(endpoint, method, data, needsAuth) {
    const url = \`\${this.baseUrl}\${endpoint}\`;
    const headers = {
      'User-Agent': 'KernelApiClient/1.0',
    };

    if (data && !(data instanceof FormData) && method !== 'GET' && method !== 'HEAD') {
        headers['Content-Type'] = 'application/json';
    }
    
    if (needsAuth && this.apiToken) {
      headers['Authorization'] = \`Token \${this.apiToken}\`;
    } else if (needsAuth && !this.apiToken) {
      console.warn(\`API endpoint \${endpoint} requires authentication, but no API token was provided.\`);
    }

    const fetchOptions = {
      method,
      headers,
    };

    if (data !== undefined && method !== 'GET' && method !== 'HEAD') {
      if (data instanceof FormData) {
        fetchOptions.body = data;
      } else {
        fetchOptions.body = JSON.stringify(data);
      }
    } else if (data !== undefined && (method === 'GET' || method === 'HEAD')) {
        console.warn(\`Data payload for GET/HEAD request to \${endpoint} will be ignored by fetch. Consider moving data to query parameters if applicable.\`);
    }

    try {
      const response = await this.customFetch(url, fetchOptions);
      if (!response.ok) {
        let errorData;
        try {
          errorData = await response.json();
        } catch (e) {
          errorData = { message: response.statusText };
        }
        const error = new Error(\`\${method} \${endpoint} failed with status \${response.status}: \${errorData.message || response.statusText}\`);
        error.status = response.status;
        error.data = errorData;
        throw error;
      }

      if (response.status === 204) { // No Content
        return; 
      }
      
      let responseData;
      const contentType = response.headers.get('content-type');
      if (contentType && contentType.includes('application/json')) {
          responseData = await response.json();
      } else {
          responseData = await response.text(); // Or handle other content types as needed
      }
      
      // Assuming Siyuan API often wraps data in a top-level 'data' field
      // This might need to be more flexible based on actual API responses
      return responseData.data !== undefined ? responseData.data : responseData;

    } catch (error) {
      // If it's an error we threw deliberately from !response.ok, rethrow it
      if (error.status) throw error; 
      // Otherwise, it's likely a network error or an issue with customFetch itself
      const networkError = new Error(\`Network error during \${method} \${endpoint}: \${error.message}\`);
      networkError.cause = error;
      throw networkError;
    }
  }
`;

    apiDefs.forEach(apiDef => {
        const methodName = apiDef.en;
        if (!methodName) {
            console.warn(`API definition missing 'en' name, skipping:`, apiDef);
            return;
        }
        const methodSignatureTest = `async ${methodName}(`;
        if (classBody.includes(methodSignatureTest)) { // Basic check for duplicates
            console.warn(`Duplicate method name '${methodName}' detected. Skipping subsequent definition from group '${apiDef.groupName}'. Check apiDef: ${apiDef.endpoint}`);
            return;
        }

        // Determine if the method needs a data parameter based on HTTP method OR if a request schema is defined
        const needsDataParam = (apiDef.method !== 'GET' && apiDef.method !== 'HEAD') || apiDef.zodRequestSchema;
        const params = needsDataParam ? 'data' : '';

        classBody += `\n${generateMethodJsDoc(apiDef, needsDataParam)}`;
        classBody += `  async ${methodName}(${params}) {\n`;
        classBody += `    return this._fetchWrapper('${apiDef.endpoint}', '${apiDef.method}', ${params}, ${!!apiDef.needAuth});\n  }\n`;
        methodCount++; // Increment counter
    });

    classBody += `
}

export default KernelApiClient;
`;

    const finalClientCode = GENERATED_BANNER + classBody;

    try {
        fs.writeFileSync(OUTPUT_FILE, finalClientCode);
        console.log(`Successfully generated Kernel API client at: ${OUTPUT_FILE}`);
        console.log(`Total API methods generated: ${methodCount}`); // Log the count

        // Test import the generated client
        try {
            const clientModule = await import(url.pathToFileURL(OUTPUT_FILE).href);
            const TestClient = clientModule.default; // Assuming default export
            if (typeof TestClient === 'function' && TestClient.name === 'KernelApiClient') {
                console.log('Generated client can be successfully imported and is a class named KernelApiClient.');
            } else {
                console.error('Generated client was imported, but it is not a class named KernelApiClient or not exported correctly as default.');
            }
        } catch (e) {
            console.error('Failed to test-import the generated client:', e);
        }

    } catch (error) {
        console.error(`Failed to write Kernel API client: ${error}`);
    }
}

(async () => {
    await generateKernelApiClient();
})();